"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/index.ts
var lib_exports = {};
__export(lib_exports, {
  ChatMessageType: () => ChatMessageType,
  LiveChatEvents: () => LiveChatEvents,
  YoutubeiExtractor: () => YoutubeiExtractor,
  generateOauthTokens: () => generateOauthTokens,
  getLiveChat: () => getLiveChat,
  getYoutubeiInstance: () => getYoutubeiInstance,
  objectToToken: () => objectToToken,
  tokenToObject: () => tokenToObject
});
module.exports = __toCommonJS(lib_exports);
var import_youtubei4 = __toESM(require("youtubei.js"));

// lib/common/tokenUtils.ts
function objectToToken(tokens) {
  return Object.entries(tokens).map(([k, v]) => `${k}=${v instanceof Date ? v.toISOString() : v}`).join("; ");
}
function tokenToObject(token) {
  if (!token.includes("; ") || !token.includes("=")) throw new Error("Error: this is not a valid authentication token. Make sure you are putting the entire string instead of just what's behind access_token=");
  const kvPair = token.split("; ");
  const validKeys = ["access_token", "expiry_date", "expires_in", "refresh_token", "scope", "token_type", "client"];
  let finalObject = {};
  for (let kv of kvPair) {
    const [key, value] = kv.split("=");
    if (!validKeys.includes(key)) continue;
    finalObject[key] = Number.isNaN(Number(value)) ? value : Number(value);
  }
  const requiredKeys = ["access_token", "expiry_date", "refresh_token"];
  for (const key of requiredKeys) {
    if (!(key in finalObject)) throw new Error(`Error: Invalid authentication keys. Missing the required key ${key}. Make sure you are putting the entire string instead of just what's behind access_token=`);
  }
  return finalObject;
}

// lib/Extractor/Youtube.ts
var import_discord_player = require("discord-player");
var import_youtubei2 = __toESM(require("youtubei.js"));
var import_extractor = require("@discord-player/extractor");

// lib/common/webToReadable.ts
var import_stream = require("stream");
var import_youtubei = require("youtubei.js");
async function createReadableFromWeb(readStream, highWaterMark = 1024 * 512) {
  const readable = new import_stream.PassThrough({
    highWaterMark
  });
  (async () => {
    for await (const chunk of import_youtubei.Utils.streamToIterable(readStream)) {
      if (readable.destroyed) continue;
      const shouldWrite = readable.write(chunk);
      if (!shouldWrite) await new Promise((res) => readable.once("drain", () => res(null)));
    }
  })();
  readable._destroy = () => {
    readable.destroyed = true;
    readable.destroy();
  };
  return readable;
}

// lib/common/generateYTStream.ts
var DEFAULT_DOWNLOAD_OPTIONS = {
  quality: "best",
  format: "mp4",
  type: "audio"
};
async function streamFromYT(query, innerTube, options = { overrideDownloadOptions: DEFAULT_DOWNLOAD_OPTIONS }) {
  const context = YoutubeiExtractor.getStreamingContext();
  let id = new URL(query.url).searchParams.get("v");
  if (!id) id = query.url.split("/").at(-1)?.split("?").at(0);
  const videoInfo = await innerTube.getBasicInfo(id, context.useClient);
  if (videoInfo.basic_info.is_live) return videoInfo.streaming_data?.hls_manifest_url;
  const download = await videoInfo.download(options.overrideDownloadOptions ?? DEFAULT_DOWNLOAD_OPTIONS);
  const stream = createReadableFromWeb(download, context.highWaterMark);
  return stream;
}

// lib/Extractor/Youtube.ts
var import_node_async_hooks = require("async_hooks");
var YoutubeiExtractor = class _YoutubeiExtractor extends import_discord_player.BaseExtractor {
  static identifier = "com.retrouser955.discord-player.discord-player-youtubei";
  innerTube;
  _stream;
  static instance;
  priority = 2;
  static ytContext = new import_node_async_hooks.AsyncLocalStorage();
  static setClientMode(client) {
    if (!this.instance) throw new Error("Cannot find Youtubei's instance");
    if (!this.instance.options.streamOptions) this.instance.options.streamOptions = { useClient: client };
    else this.instance.options.streamOptions.useClient = client;
  }
  static getStreamingContext() {
    const ctx = _YoutubeiExtractor.ytContext.getStore();
    if (!ctx) throw new Error("INVALID INVOKCATION");
    return ctx;
  }
  async activate() {
    this.protocols = ["ytsearch", "youtube"];
    this.innerTube = await import_youtubei2.default.create({
      retrieve_player: this.options.disablePlayer == void 0 ? true : !this.options.disablePlayer
    });
    if (typeof this.options.createStream === "function") {
      this._stream = this.options.createStream;
    } else {
      this._stream = (q, _) => {
        return _YoutubeiExtractor.ytContext.run({
          useClient: this.options.streamOptions?.useClient ?? "ANDROID",
          highWaterMark: this.options.streamOptions?.highWaterMark
        }, async () => {
          return streamFromYT(q, this.innerTube, {
            overrideDownloadOptions: this.options.overrideDownloadOptions
          });
        });
      };
    }
    _YoutubeiExtractor.instance = this;
    if (this.options.authentication) {
      try {
        await this.signIn(this.options.authentication);
        const info = await this.innerTube.account.getInfo();
        this.context.player.debug(info.contents?.contents ? `Signed into YouTube using the name: ${info.contents.contents[0]?.account_name?.text ?? "UNKNOWN ACCOUNT"}` : `Signed into YouTube using the client name: ${this.innerTube.session.client_name}@${this.innerTube.session.client_version}`);
      } catch (error) {
        if (this.options.ignoreSignInErrors) process.emitWarning(`Unable to sign into YouTube

${error}`);
        else throw error;
      }
    }
  }
  async signIn(tokens) {
    const tkn = tokenToObject(tokens);
    await this.innerTube.session.signIn(tkn);
  }
  async deactivate() {
    this.protocols = [];
    if (this.options.signOutOnDeactive && this.innerTube.session.logged_in) await this.innerTube.session.signOut();
  }
  async validate(query, type) {
    if (typeof query !== "string") return false;
    return [
      import_discord_player.QueryType.YOUTUBE,
      import_discord_player.QueryType.YOUTUBE_PLAYLIST,
      import_discord_player.QueryType.YOUTUBE_SEARCH,
      import_discord_player.QueryType.YOUTUBE_VIDEO,
      import_discord_player.QueryType.AUTO,
      import_discord_player.QueryType.AUTO_SEARCH
    ].some((r) => r === type);
  }
  async bridge(track, ext) {
    if (ext?.identifier === this.identifier) return this.stream(track);
    let protocol;
    if (this.options.overrideBridgeMode) {
      protocol = this.options.overrideBridgeMode;
    } else {
      if (this.innerTube.session.logged_in) protocol = "ytmusic";
      else protocol = "yt";
    }
    const query = ext?.createBridgeQuery(track) || `${track.author} - ${track.title}${protocol === "yt" ? " (official audio)" : ""}`;
    switch (protocol) {
      case "ytmusic": {
        try {
          let stream = await this.bridgeFromYTMusic(query, track);
          if (!stream) {
            this.context.player.debug("Unable to bridge from Youtube music. Falling back to default behavior");
            stream = await this.bridgeFromYT(query, track);
          }
          return stream;
        } catch (error) {
          this.context.player.debug("Unable to bridge from youtube music due to an error. Falling back to default behavior\n\n" + error);
          const stream = await this.bridgeFromYT(query, track);
          return stream;
        }
      }
      default: {
        const stream = await this.bridgeFromYT(query, track);
        return stream;
      }
    }
  }
  async bridgeFromYTMusic(query, track) {
    const musicSearch = await this.innerTube.music.search(query, {
      type: "song"
    });
    if (!musicSearch.songs) return null;
    if (!musicSearch.songs.contents || musicSearch.songs.contents.length === 0) return null;
    if (!musicSearch.songs.contents[0].id) return null;
    const info = await this.innerTube.music.getInfo(musicSearch.songs.contents[0].id);
    const metadata = new import_discord_player.Track(this.context.player, {
      title: info.basic_info.title ?? "UNKNOWN TITLE",
      duration: import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS((info.basic_info.duration || 0) * 1e3)),
      author: info.basic_info.author ?? "UNKNOWN AUTHOR",
      views: info.basic_info.view_count,
      thumbnail: info.basic_info.thumbnail?.at(0)?.url,
      url: `https://youtube.com/watch?v=${info.basic_info.id}&dpymeta=ytmusic`,
      source: "youtube",
      queryType: "youtubeVideo",
      live: false
    });
    track.setMetadata(metadata);
    const webStream = await info.download({
      type: "audio",
      quality: "best",
      format: "mp4"
    });
    return createReadableFromWeb(webStream, this.options.streamOptions?.highWaterMark);
  }
  async bridgeFromYT(query, track) {
    const youtubeTrack = await this.handle(query, {
      type: import_discord_player.QueryType.YOUTUBE_SEARCH,
      requestedBy: track.requestedBy
    });
    if (youtubeTrack.tracks.length === 0) return null;
    track.setMetadata({
      bridge: youtubeTrack.tracks[0]
    });
    return this.stream(youtubeTrack.tracks[0]);
  }
  async handle(query, context) {
    if (context.protocol === "ytsearch") context.type = import_discord_player.QueryType.YOUTUBE_SEARCH;
    query = query.includes("youtube.com") ? query.replace(/(m(usic)?|gaming)\./, "") : query;
    if (!query.includes("list=RD") && import_extractor.YouTubeExtractor.validateURL(query)) context.type = import_discord_player.QueryType.YOUTUBE_VIDEO;
    if (context.type === import_discord_player.QueryType.YOUTUBE_PLAYLIST) {
      const url = new URL(query);
      if (url.searchParams.has("v") && url.searchParams.has("list")) context.type = import_discord_player.QueryType.YOUTUBE_VIDEO;
    }
    switch (context.type) {
      case import_discord_player.QueryType.YOUTUBE_PLAYLIST: {
        const playlistUrl = new URL(query);
        const plId = playlistUrl.searchParams.get("list");
        let playlist = await this.innerTube.getPlaylist(plId);
        const pl = new import_discord_player.Playlist(this.context.player, {
          title: playlist.info.title ?? "UNKNOWN PLAYLIST",
          thumbnail: playlist.info.thumbnails[0].url,
          description: playlist.info.description ?? playlist.info.title ?? "UNKNOWN DESCRIPTION",
          type: "playlist",
          author: {
            name: playlist?.channels[0]?.author?.name ?? playlist.info.author.name ?? "UNKNOWN AUTHOR",
            url: playlist?.channels[0]?.author?.url ?? playlist.info.author.url ?? "UNKNOWN AUTHOR"
          },
          tracks: [],
          id: plId,
          url: query,
          source: "youtube"
        });
        pl.tracks = [];
        let plTracks = playlist.videos.filter((v) => v.type === "PlaylistVideo").map(
          (v) => {
            const duration = import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS(v.duration.seconds * 1e3));
            const raw = {
              duration_ms: v.duration.seconds * 1e3,
              live: v.is_live,
              duration
            };
            return new import_discord_player.Track(this.context.player, {
              title: v.title.text ?? "UNKNOWN TITLE",
              duration,
              thumbnail: v.thumbnails[0]?.url,
              author: v.author.name,
              requestedBy: context.requestedBy,
              url: `https://youtube.com/watch?v=${v.id}`,
              raw,
              playlist: pl,
              source: "youtube",
              queryType: "youtubeVideo",
              async requestMetadata() {
                return this.raw;
              },
              metadata: raw,
              live: v.is_live
            });
          }
        );
        while (playlist.has_continuation) {
          playlist = await playlist.getContinuation();
          plTracks.push(...playlist.videos.filter((v) => v.type === "PlaylistVideo").map(
            (v) => {
              const duration = import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS(v.duration.seconds * 1e3));
              const raw = {
                duration_ms: v.duration.seconds * 1e3,
                live: v.is_live,
                duration
              };
              return new import_discord_player.Track(this.context.player, {
                title: v.title.text ?? "UNKNOWN TITLE",
                duration,
                thumbnail: v.thumbnails[0]?.url,
                author: v.author.name,
                requestedBy: context.requestedBy,
                url: `https://youtube.com/watch?v=${v.id}`,
                raw,
                playlist: pl,
                source: "youtube",
                queryType: "youtubeVideo",
                async requestMetadata() {
                  return this.raw;
                },
                metadata: raw,
                live: v.is_live
              });
            }
          ));
        }
        pl.tracks = plTracks;
        return {
          playlist: pl,
          tracks: pl.tracks
        };
      }
      case import_discord_player.QueryType.YOUTUBE_VIDEO: {
        let videoId = new URL(query).searchParams.get("v");
        if (!videoId) videoId = query.split("/").at(-1).split("?")[0];
        const vid = await this.innerTube.getBasicInfo(videoId);
        const duration = import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS((vid.basic_info.duration ?? 0) * 1e3));
        const uploadTime = vid.basic_info.start_timestamp;
        const raw = {
          duration_ms: vid.basic_info.duration * 1e3,
          live: vid.basic_info.is_live,
          duration,
          startTime: uploadTime
        };
        return {
          playlist: null,
          tracks: [
            new import_discord_player.Track(this.context.player, {
              title: vid.basic_info.title ?? "UNKNOWN TITLE",
              thumbnail: vid.basic_info.thumbnail?.at(0)?.url,
              description: vid.basic_info.short_description,
              author: vid.basic_info.channel?.name,
              requestedBy: context.requestedBy,
              url: `https://youtube.com/watch?v=${vid.basic_info.id}`,
              views: vid.basic_info.view_count,
              duration,
              raw,
              source: "youtube",
              queryType: "youtubeVideo",
              async requestMetadata() {
                return this.raw;
              },
              metadata: raw,
              live: vid.basic_info.is_live
            })
          ]
        };
      }
      default: {
        const search = await this.innerTube.search(query);
        const videos = search.videos.filter((v) => v.type === "Video");
        return {
          playlist: null,
          tracks: videos.map((v) => this.buildTrack(v, context))
        };
      }
    }
  }
  buildTrack(vid, context, pl) {
    const duration = import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS(vid.duration.seconds * 1e3));
    const raw = {
      duration_ms: vid.duration.seconds * 1e3,
      live: vid.is_live
    };
    const track = new import_discord_player.Track(this.context.player, {
      title: vid.title.text ?? "UNKNOWN YOUTUBE VIDEO",
      thumbnail: vid.best_thumbnail?.url ?? vid.thumbnails[0]?.url ?? "",
      description: vid.description ?? vid.title ?? "UNKNOWN DESCRIPTION",
      author: vid.author?.name ?? "UNKNOWN AUTHOR",
      requestedBy: context.requestedBy,
      url: `https://youtube.com/watch?v=${vid.id}`,
      views: parseInt((vid.view_count?.text ?? "0").replaceAll(",", "")),
      duration,
      raw,
      playlist: pl,
      source: "youtube",
      queryType: "youtubeVideo",
      async requestMetadata() {
        return this.raw;
      },
      metadata: raw,
      live: vid.is_live
    });
    track.extractor = this;
    return track;
  }
  stream(info) {
    return this._stream(info, this);
  }
  async getRelatedTracks(track, history) {
    let id = new URL(track.url).searchParams.get("v");
    if (!id) id = track.url.split("/").at(-1)?.split("?").at(0);
    const videoInfo = await this.innerTube.getInfo(id);
    const next = videoInfo.watch_next_feed;
    const recommended = next.filter(
      (v) => !history.tracks.some((x) => x.url === `https://youtube.com/watch?v=${v.id}`) && v.type === "CompactVideo"
    );
    if (!recommended) {
      this.context.player.debug("Unable to fetch recommendations");
      return this.#emptyResponse();
    }
    const trackConstruct = recommended.map((v) => {
      const duration = import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS(v.duration.seconds * 1e3));
      const raw = {
        live: v.is_live,
        duration_ms: v.duration.seconds * 1e3,
        duration
      };
      return new import_discord_player.Track(this.context.player, {
        title: v.title?.text ?? "UNKNOWN TITLE",
        thumbnail: v.best_thumbnail?.url ?? v.thumbnails[0]?.url,
        author: v.author?.name ?? "UNKNOWN AUTHOR",
        requestedBy: track.requestedBy,
        url: `https://youtube.com/watch?v=${v.id}`,
        views: parseInt((v.view_count?.text ?? "0").replaceAll(",", "")),
        duration,
        raw,
        source: "youtube",
        queryType: "youtubeVideo",
        metadata: raw,
        async requestMetadata() {
          return this.raw;
        },
        live: v.is_live
      });
    });
    return {
      playlist: null,
      tracks: trackConstruct
    };
  }
  #emptyResponse() {
    return {
      playlist: null,
      tracks: []
    };
  }
};

// lib/common/getInstance.ts
function getYoutubeiInstance() {
  return YoutubeiExtractor.instance?.innerTube;
}

// lib/utils/live/LiveChat.ts
var import_tiny_typed_emitter = require("tiny-typed-emitter");

// lib/utils/live/LiveChatAuthor.ts
var LiveChatAuthor = class {
  username;
  url;
  thumbnail;
  verifiedChannel;
  verifiedArtist;
  isMod;
  id;
  raw;
  constructor(author) {
    this.username = author.name;
    this.url = author.url;
    this.thumbnail = author.best_thumbnail?.url ?? author.thumbnails[0].url;
    this.verifiedChannel = author.is_verified || false;
    this.verifiedArtist = author.is_verified_artist || false;
    this.isMod = author.is_moderator || false;
    this.id = author.id;
    this.raw = author;
  }
};

// lib/utils/live/LiveChatMessage.ts
var ChatMessageType = /* @__PURE__ */ ((ChatMessageType2) => {
  ChatMessageType2[ChatMessageType2["Regular"] = 1] = "Regular";
  ChatMessageType2[ChatMessageType2["Premium"] = 2] = "Premium";
  ChatMessageType2[ChatMessageType2["PremiumSticker"] = 3] = "PremiumSticker";
  return ChatMessageType2;
})(ChatMessageType || {});
var LiveChatMessage = class {
  author;
  type;
  content;
  timestamp;
  constructor(chatUpdate, type) {
    this.author = new LiveChatAuthor(chatUpdate.author);
    this.type = type;
    this.timestamp = chatUpdate.timestamp || Date.now();
    if (chatUpdate.type === "LiveChatTextMessage" || chatUpdate.type === "LiveChatPaidMessage") {
      this.content = chatUpdate.message.toString();
    }
  }
};

// lib/utils/live/LiveChat.ts
var import_youtubei3 = require("youtubei.js");
var LiveChatEvents = /* @__PURE__ */ ((LiveChatEvents2) => {
  LiveChatEvents2["MessageCreate"] = "messageCreate";
  return LiveChatEvents2;
})(LiveChatEvents || {});
var LiveChat = class extends import_tiny_typed_emitter.TypedEmitter {
  chat;
  // this is scuffed but i cant access 'this' inside other non-arrow functions
  chatUpdateHandler = (action) => {
    if (action.is(import_youtubei3.YTNodes.AddChatItemAction)) {
      const { item } = action.as(import_youtubei3.YTNodes.AddChatItemAction);
      switch (item.type) {
        case "LiveChatTextMessage": {
          this.emit("messageCreate" /* MessageCreate */, new LiveChatMessage(item, 1 /* Regular */));
          break;
        }
        case "LiveChatPaidMessage": {
          this.emit("messageCreate" /* MessageCreate */, new LiveChatMessage(item, 2 /* Premium */));
          break;
        }
        case "LiveChatPaidSticker": {
          this.emit("messageCreate" /* MessageCreate */, new LiveChatMessage(item, 3 /* PremiumSticker */));
          break;
        }
        default: {
          break;
        }
      }
    }
  };
  constructor(chat) {
    super();
    chat.on("chat-update", this.chatUpdateHandler);
    this.chat = chat;
  }
  destroy() {
    this.chat.off("chat-update", this.chatUpdateHandler);
    this.chat.stop();
  }
};

// lib/utils/live/getLiveChat.ts
var YOUTUBE_URL_REGEX = /^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube(?:-nocookie)?\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|live\/|v\/)?)([\w\-]+)(\S+)?$/;
function parseYoutubeVideo(videoUrl) {
  if (!YOUTUBE_URL_REGEX.test(videoUrl)) throw new Error("This is not a valid video URL");
  const idExtractor = new URL(videoUrl);
  let id = idExtractor.searchParams.get("v");
  if (!id) id = videoUrl.split("/").at(-1)?.split("?").at(0);
  return id;
}
async function getLiveChat(videoUrl, ext) {
  const instance = YoutubeiExtractor.instance ?? ext;
  if (!instance) throw new Error("Invoked getLiveChat before player.extractors.register");
  const innertube = instance.innerTube;
  const videoId = parseYoutubeVideo(videoUrl);
  const info = await innertube.getInfo(videoId);
  const chat = info.getLiveChat();
  chat.start();
  return new LiveChat(chat);
}

// lib/index.ts
var exit = (message, clean) => {
  if (clean) {
    console.log(message);
    process.exit(0);
  }
  throw new Error(message);
};
async function generateOauthTokens() {
  const youtube = await import_youtubei4.default.create();
  youtube.session.on("auth-pending", (data) => {
    const { verification_url: verify, user_code } = data;
    console.log(`Follow this URL: ${verify} and enter this code: ${user_code}
Make sure you are using a throwaway account to login. Using your main account may result in ban or suspension`);
  });
  youtube.session.on("auth-error", (err) => {
    exit(err.message, false);
  });
  youtube.session.on("auth", (data) => {
    if (!data.credentials) exit("Something went wrong", false);
    console.log("Your cookies are printed down below");
    console.log(objectToToken(data.credentials));
    exit("Done Getting the credentials", true);
  });
  await youtube.session.signIn();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChatMessageType,
  LiveChatEvents,
  YoutubeiExtractor,
  generateOauthTokens,
  getLiveChat,
  getYoutubeiInstance,
  objectToToken,
  tokenToObject
});
