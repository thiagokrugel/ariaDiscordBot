"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/index.ts
var lib_exports = {};
__export(lib_exports, {
  YoutubeiExtractor: () => YoutubeiExtractor,
  generateOauthTokens: () => generateOauthTokens,
  getYoutubeiInstance: () => getYoutubeiInstance,
  objectToToken: () => objectToToken,
  tokenToObject: () => tokenToObject
});
module.exports = __toCommonJS(lib_exports);
var import_youtubei2 = __toESM(require("youtubei.js"));

// lib/common/tokenUtils.ts
function objectToToken(tokens) {
  return Object.entries(tokens).map(([k, v]) => `${k}=${v instanceof Date ? v.toISOString() : v}`).join("; ");
}
function tokenToObject(token) {
  const kvPair = token.split("; ");
  const validKeys = ["access_token", "expiry_date", "expires_in", "refresh_token", "scope", "token_type", "client"];
  let finalObject = {};
  for (let kv of kvPair) {
    const [key, value] = kv.split("=");
    if (!validKeys.includes(key)) continue;
    finalObject[key] = Number.isNaN(Number(value)) ? value : Number(value);
  }
  return finalObject;
}

// lib/Extractor/Youtube.ts
var import_discord_player = require("discord-player");
var import_youtubei = __toESM(require("youtubei.js"));
var import_node_stream = require("stream");
var import_extractor = require("@discord-player/extractor");

// lib/common/generateYTStream.ts
var import_stream = require("stream");
var DEFAULT_DOWNLOAD_OPTIONS = {
  quality: "best",
  format: "mp4",
  type: "audio"
};
async function streamFromYT(query, innerTube, options = { overrideDownloadOptions: DEFAULT_DOWNLOAD_OPTIONS }) {
  const context = YoutubeiExtractor.getStreamingContext();
  let id = new URL(query.url).searchParams.get("v");
  if (!id) id = query.url.split("/").at(-1)?.split("?").at(0);
  const videoInfo = await innerTube.getBasicInfo(id, context.useClient);
  if (videoInfo.basic_info.is_live && videoInfo.basic_info.is_family_safe) return videoInfo.streaming_data?.hls_manifest_url;
  const download = await videoInfo.download(options.overrideDownloadOptions ?? DEFAULT_DOWNLOAD_OPTIONS);
  const stream = import_stream.Readable.fromWeb(download);
  return stream;
}

// lib/Extractor/Youtube.ts
var import_node_async_hooks = require("async_hooks");

// lib/common/randomAuthToken.ts
function getRandomOauthToken(tokens) {
  const randomInt = Math.round(Math.random() * (tokens.length - 1));
  return tokens[randomInt];
}

// lib/Extractor/Youtube.ts
var YoutubeiExtractor = class _YoutubeiExtractor extends import_discord_player.BaseExtractor {
  static identifier = "com.retrouser955.discord-player.discord-player-youtubei";
  innerTube;
  _stream;
  static instance;
  priority = 2;
  static ytContext = new import_node_async_hooks.AsyncLocalStorage();
  rotatorOnEachReq = false;
  #oauthTokens = [];
  static setClientMode(client) {
    if (!this.instance) throw new Error("Cannot find Youtubei's instance");
    if (!this.instance.options.streamOptions) this.instance.options.streamOptions = { useClient: client };
    else this.instance.options.streamOptions.useClient = client;
  }
  static getStreamingContext() {
    const ctx = _YoutubeiExtractor.ytContext.getStore();
    if (!ctx) throw new Error("INVALID INVOKCATION");
    return ctx;
  }
  async activate() {
    this.protocols = ["ytsearch", "youtube"];
    this.innerTube = await import_youtubei.default.create({
      retrieve_player: this.options.disablePlayer == void 0 ? true : !this.options.disablePlayer
    });
    if (typeof this.options.createStream === "function") {
      this._stream = this.options.createStream;
    } else {
      this._stream = (q, _) => {
        return _YoutubeiExtractor.ytContext.run({
          useClient: this.options.streamOptions?.useClient ?? "WEB"
        }, async () => {
          if (this.rotatorOnEachReq) await this.#rotateTokens();
          return streamFromYT(q, this.innerTube, {
            overrideDownloadOptions: this.options.overrideDownloadOptions
          });
        });
      };
    }
    _YoutubeiExtractor.instance = this;
    if (this.options.rotator) {
      if (this.options.rotator.rotationStrategy === "shard") {
        const tokenToUse = this.options.rotator.currentShard % this.options.rotator.authentications.length;
        this.context.player.debug(`Shard count is ${this.options.rotator.currentShard} thus using rotator.authentication[${tokenToUse}]`);
        await this.#signIn(this.options.rotator.authentications[tokenToUse]);
        const info = await this.innerTube.account.getInfo();
        this.context.player.debug(info.contents?.contents ? `Signed into YouTube using the name: ${info.contents.contents[0]?.account_name?.text ?? "UNKNOWN ACCOUNT"}` : `Signed into YouTube using the client name: ${this.innerTube.session.client_name}@${this.innerTube.session.client_version}`);
        return;
      }
      this.#oauthTokens = this.options.rotator.authentications.map((v) => tokenToObject(v));
      this.rotatorOnEachReq = true;
      return;
    }
    if (this.options.authentication) {
      try {
        await this.#signIn(this.options.authentication);
        const info = await this.innerTube.account.getInfo();
        this.context.player.debug(info.contents?.contents ? `Signed into YouTube using the name: ${info.contents.contents[0]?.account_name?.text ?? "UNKNOWN ACCOUNT"}` : `Signed into YouTube using the client name: ${this.innerTube.session.client_name}@${this.innerTube.session.client_version}`);
      } catch (error) {
        this.context.player.debug(`Unable to sign into Innertube:

${error}`);
      }
    }
  }
  async #signIn(tokens) {
    const tkn = tokenToObject(tokens);
    await this.innerTube.session.signIn(tkn);
  }
  async deactivate() {
    this.protocols = [];
    if (this.options.signOutOnDeactive && this.innerTube.session.logged_in) await this.innerTube.session.signOut();
  }
  async validate(query, type) {
    if (typeof query !== "string") return false;
    return [
      import_discord_player.QueryType.YOUTUBE,
      import_discord_player.QueryType.YOUTUBE_PLAYLIST,
      import_discord_player.QueryType.YOUTUBE_SEARCH,
      import_discord_player.QueryType.YOUTUBE_VIDEO,
      import_discord_player.QueryType.AUTO,
      import_discord_player.QueryType.AUTO_SEARCH
    ].some((r) => r === type);
  }
  async bridge(track, ext) {
    const query = ext?.createBridgeQuery(track) || `${track.author} - ${track.title} (official audio)`;
    let protocol;
    if (this.options.overrideBridgeMode) {
      protocol = this.options.overrideBridgeMode;
    } else {
      if (this.innerTube.session.logged_in) protocol = "ytmusic";
      else protocol = "yt";
    }
    switch (protocol) {
      case "ytmusic": {
        try {
          let stream = await this.bridgeFromYTMusic(query, track);
          if (!stream) {
            this.context.player.debug("Unable to bridge from Youtube music. Falling back to default behavior");
            stream = await this.bridgeFromYT(query, track);
          }
          return stream;
        } catch (error) {
          this.context.player.debug("Unable to bridge from youtube music due to an error. Falling back to default behavior\n\n" + error);
          const stream = await this.bridgeFromYT(query, track);
          return stream;
        }
      }
      default: {
        const stream = await this.bridgeFromYT(query, track);
        return stream;
      }
    }
  }
  async bridgeFromYTMusic(query, track) {
    const musicSearch = await this.innerTube.music.search(query, {
      type: "song"
    });
    if (!musicSearch.songs) return null;
    if (!musicSearch.songs.contents || musicSearch.songs.contents.length === 0) return null;
    if (!musicSearch.songs.contents[0].id) return null;
    const info = await this.innerTube.music.getInfo(musicSearch.songs.contents[0].id);
    const metadata = new import_discord_player.Track(this.context.player, {
      title: info.basic_info.title ?? "UNKNOWN TITLE",
      duration: import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS((info.basic_info.duration || 0) * 1e3)),
      author: info.basic_info.author ?? "UNKNOWN AUTHOR",
      views: info.basic_info.view_count,
      thumbnail: info.basic_info.thumbnail?.at(0)?.url,
      url: `https://youtube.com/watch?v=${info.basic_info.id}&dpymeta=ytmusic`,
      source: "youtube",
      queryType: "youtubeVideo"
    });
    track.setMetadata(metadata);
    const webStream = await info.download({
      type: "audio",
      quality: "best",
      format: "mp4"
    });
    return import_node_stream.Readable.fromWeb(webStream);
  }
  async bridgeFromYT(query, track) {
    const youtubeTrack = await this.handle(query, {
      type: import_discord_player.QueryType.YOUTUBE_SEARCH,
      requestedBy: track.requestedBy
    });
    if (youtubeTrack.tracks.length === 0) return null;
    track.setMetadata({
      bridge: youtubeTrack.tracks[0]
    });
    return this.stream(youtubeTrack.tracks[0]);
  }
  async #rotateTokens() {
    this.context.player.debug("Rotation strategy 'random' detected. Attempting to rotate");
    const token = getRandomOauthToken(this.#oauthTokens);
    await this.innerTube.session.signIn(token);
  }
  async handle(query, context) {
    if (context.protocol === "ytsearch") context.type = import_discord_player.QueryType.YOUTUBE_SEARCH;
    query = query.includes("youtube.com") ? query.replace(/(m(usic)?|gaming)\./, "") : query;
    if (!query.includes("list=RD") && import_extractor.YouTubeExtractor.validateURL(query)) context.type = import_discord_player.QueryType.YOUTUBE_VIDEO;
    if (this.rotatorOnEachReq) await this.#rotateTokens();
    if (context.type === import_discord_player.QueryType.YOUTUBE_PLAYLIST) {
      const url = new URL(query);
      if (url.searchParams.has("v") && url.searchParams.has("list")) context.type = import_discord_player.QueryType.YOUTUBE_VIDEO;
    }
    switch (context.type) {
      case import_discord_player.QueryType.YOUTUBE_PLAYLIST: {
        const playlistUrl = new URL(query);
        const plId = playlistUrl.searchParams.get("list");
        let playlist = await this.innerTube.getPlaylist(plId);
        const pl = new import_discord_player.Playlist(this.context.player, {
          title: playlist.info.title ?? "UNKNOWN PLAYLIST",
          thumbnail: playlist.info.thumbnails[0].url,
          description: playlist.info.description ?? playlist.info.title ?? "UNKNOWN DESCRIPTION",
          type: "playlist",
          author: {
            name: playlist?.channels[0]?.author?.name ?? playlist.info.author.name ?? "UNKNOWN AUTHOR",
            url: playlist?.channels[0]?.author?.url ?? playlist.info.author.url ?? "UNKNOWN AUTHOR"
          },
          tracks: [],
          id: plId,
          url: query,
          source: "youtube"
        });
        pl.tracks = [];
        let plTracks = playlist.videos.filter((v) => v.type === "PlaylistVideo").map(
          (v) => {
            const duration = import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS(v.duration.seconds * 1e3));
            const raw = {
              duration_ms: v.duration.seconds * 1e3,
              live: v.is_live,
              duration
            };
            return new import_discord_player.Track(this.context.player, {
              title: v.title.text ?? "UNKNOWN TITLE",
              duration,
              thumbnail: v.thumbnails[0]?.url,
              author: v.author.name,
              requestedBy: context.requestedBy,
              url: `https://youtube.com/watch?v=${v.id}`,
              raw,
              playlist: pl,
              source: "youtube",
              queryType: "youtubeVideo",
              async requestMetadata() {
                return this.raw;
              },
              metadata: raw
            });
          }
        );
        while (playlist.has_continuation) {
          playlist = await playlist.getContinuation();
          plTracks.push(...playlist.videos.filter((v) => v.type === "PlaylistVideo").map(
            (v) => {
              const duration = import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS(v.duration.seconds * 1e3));
              const raw = {
                duration_ms: v.duration.seconds * 1e3,
                live: v.is_live,
                duration
              };
              return new import_discord_player.Track(this.context.player, {
                title: v.title.text ?? "UNKNOWN TITLE",
                duration,
                thumbnail: v.thumbnails[0]?.url,
                author: v.author.name,
                requestedBy: context.requestedBy,
                url: `https://youtube.com/watch?v=${v.id}`,
                raw,
                playlist: pl,
                source: "youtube",
                queryType: "youtubeVideo",
                async requestMetadata() {
                  return this.raw;
                },
                metadata: raw
              });
            }
          ));
        }
        pl.tracks = plTracks;
        return {
          playlist: pl,
          tracks: pl.tracks
        };
      }
      case import_discord_player.QueryType.YOUTUBE_VIDEO: {
        let videoId = new URL(query).searchParams.get("v");
        if (!videoId) videoId = query.split("/").at(-1).split("?")[0];
        const vid = await this.innerTube.getBasicInfo(videoId);
        const duration = import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS((vid.basic_info.duration ?? 0) * 1e3));
        const uploadTime = vid.basic_info.start_timestamp;
        const raw = {
          duration_ms: vid.basic_info.duration * 1e3,
          live: vid.basic_info.is_live,
          duration,
          startTime: uploadTime
        };
        return {
          playlist: null,
          tracks: [
            new import_discord_player.Track(this.context.player, {
              title: vid.basic_info.title ?? "UNKNOWN TITLE",
              thumbnail: vid.basic_info.thumbnail?.at(0)?.url,
              description: vid.basic_info.short_description,
              author: vid.basic_info.channel?.name,
              requestedBy: context.requestedBy,
              url: `https://youtube.com/watch?v=${vid.basic_info.id}`,
              views: vid.basic_info.view_count,
              duration,
              raw,
              source: "youtube",
              queryType: "youtubeVideo",
              async requestMetadata() {
                return this.raw;
              },
              metadata: raw
            })
          ]
        };
      }
      default: {
        const search = await this.innerTube.search(query);
        const videos = search.videos.filter((v) => v.type === "Video");
        return {
          playlist: null,
          tracks: videos.map((v) => this.buildTrack(v, context))
        };
      }
    }
  }
  buildTrack(vid, context, pl) {
    const duration = import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS(vid.duration.seconds * 1e3));
    const raw = {
      duration_ms: vid.duration.seconds * 1e3,
      live: vid.is_live
    };
    const track = new import_discord_player.Track(this.context.player, {
      title: vid.title.text ?? "UNKNOWN YOUTUBE VIDEO",
      thumbnail: vid.best_thumbnail?.url ?? vid.thumbnails[0]?.url ?? "",
      description: vid.description ?? vid.title ?? "UNKNOWN DESCRIPTION",
      author: vid.author?.name ?? "UNKNOWN AUTHOR",
      requestedBy: context.requestedBy,
      url: `https://youtube.com/watch?v=${vid.id}`,
      views: parseInt((vid.view_count?.text ?? "0").replaceAll(",", "")),
      duration,
      raw,
      playlist: pl,
      source: "youtube",
      queryType: "youtubeVideo",
      async requestMetadata() {
        return this.raw;
      },
      metadata: raw
    });
    track.extractor = this;
    return track;
  }
  stream(info) {
    return this._stream(info, this);
  }
  async getRelatedTracks(track, history) {
    let id = new URL(track.url).searchParams.get("v");
    if (!id) id = track.url.split("/").at(-1)?.split("?").at(0);
    if (this.rotatorOnEachReq) await this.#rotateTokens();
    const videoInfo = await this.innerTube.getInfo(id);
    const next = videoInfo.watch_next_feed;
    const recommended = next.filter(
      (v) => !history.tracks.some((x) => x.url === `https://youtube.com/watch?v=${v.id}`) && v.type === "CompactVideo"
    );
    if (!recommended) {
      this.context.player.debug("Unable to fetch recommendations");
      return this.#emptyResponse();
    }
    const trackConstruct = recommended.map((v) => {
      const duration = import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS(v.duration.seconds * 1e3));
      const raw = {
        live: v.is_live,
        duration_ms: v.duration.seconds * 1e3,
        duration
      };
      return new import_discord_player.Track(this.context.player, {
        title: v.title?.text ?? "UNKNOWN TITLE",
        thumbnail: v.best_thumbnail?.url ?? v.thumbnails[0]?.url,
        author: v.author?.name ?? "UNKNOWN AUTHOR",
        requestedBy: track.requestedBy,
        url: `https://youtube.com/watch?v=${v.id}`,
        views: parseInt((v.view_count?.text ?? "0").replaceAll(",", "")),
        duration,
        raw,
        source: "youtube",
        queryType: "youtubeVideo",
        metadata: raw,
        async requestMetadata() {
          return this.raw;
        }
      });
    });
    return {
      playlist: null,
      tracks: trackConstruct
    };
  }
  #emptyResponse() {
    return {
      playlist: null,
      tracks: []
    };
  }
};

// lib/common/getInstance.ts
function getYoutubeiInstance() {
  return YoutubeiExtractor.instance?.innerTube;
}

// lib/index.ts
var exit = (message, clean) => {
  if (clean) {
    console.log(message);
    process.exit(0);
  }
  throw new Error(message);
};
async function generateOauthTokens() {
  const youtube = await import_youtubei2.default.create();
  youtube.session.on("auth-pending", (data) => {
    const { verification_url: verify, user_code } = data;
    console.log(`Follow this URL: ${verify} and enter this code: ${user_code}
Make sure you are using a throwaway account to login. Using your main account may result in ban or suspension`);
  });
  youtube.session.on("auth-error", (err) => {
    exit(err.message, false);
  });
  youtube.session.on("auth", (data) => {
    if (!data.credentials) exit("Something went wrong", false);
    console.log("Your cookies are printed down below");
    console.log(objectToToken(data.credentials));
    exit("Done Getting the credentials", true);
  });
  await youtube.session.signIn();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  YoutubeiExtractor,
  generateOauthTokens,
  getYoutubeiInstance,
  objectToToken,
  tokenToObject
});
