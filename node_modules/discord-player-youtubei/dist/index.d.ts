import { Track, BaseExtractor, ExtractorStreamable, SearchQueryType, ExtractorSearchContext, ExtractorInfo, Playlist, GuildQueueHistory } from 'discord-player';
import Innertube, { InnerTubeClient, OAuth2Tokens } from 'youtubei.js';
import { DownloadOptions } from 'youtubei.js/dist/src/types';
import { Readable } from 'node:stream';
import { Video } from 'youtubei.js/dist/src/parser/nodes';
import { AsyncLocalStorage } from 'node:async_hooks';
import * as youtubei_js_agnostic from 'youtubei.js/agnostic';
import { TypedEmitter } from 'tiny-typed-emitter';
import { VideoInfo } from 'youtubei.js/dist/src/parser/youtube';
import { YTNode } from 'youtubei.js/dist/src/parser/helpers';
import { Author } from 'youtubei.js/dist/src/parser/misc';
import { ChatAction } from 'youtubei.js/dist/src/parser/youtube/LiveChat';

interface StreamOptions {
    useClient?: InnerTubeClient;
    highWaterMark?: number;
}
interface YoutubeiOptions {
    authentication?: string;
    overrideDownloadOptions?: DownloadOptions;
    createStream?: (q: Track, extractor: BaseExtractor<object>) => Promise<string | Readable>;
    signOutOnDeactive?: boolean;
    streamOptions?: StreamOptions;
    overrideBridgeMode?: "ytmusic" | "yt";
    disablePlayer?: boolean;
    ignoreSignInErrors?: boolean;
}
interface AsyncTrackingContext {
    useClient: InnerTubeClient;
    highWaterMark?: number;
}
declare class YoutubeiExtractor extends BaseExtractor<YoutubeiOptions> {
    #private;
    static identifier: string;
    innerTube: Innertube;
    _stream: (q: Track, extractor: BaseExtractor<object>) => Promise<ExtractorStreamable>;
    static instance?: YoutubeiExtractor;
    priority: number;
    static ytContext: AsyncLocalStorage<AsyncTrackingContext>;
    static setClientMode(client: InnerTubeClient): void;
    static getStreamingContext(): AsyncTrackingContext;
    activate(): Promise<void>;
    signIn(tokens: string): Promise<void>;
    deactivate(): Promise<void>;
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    bridge(track: Track, ext: BaseExtractor | null): Promise<ExtractorStreamable | null>;
    bridgeFromYTMusic(query: string, track: Track): Promise<ExtractorStreamable | null>;
    bridgeFromYT(query: string, track: Track): Promise<ExtractorStreamable | null>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    buildTrack(vid: Video, context: ExtractorSearchContext, pl?: Playlist): Track<any>;
    stream(info: Track<unknown>): Promise<ExtractorStreamable>;
    getRelatedTracks(track: Track<{
        duration_ms: number;
        live: boolean;
    }>, history: GuildQueueHistory<unknown>): Promise<ExtractorInfo>;
}

declare function objectToToken(tokens: OAuth2Tokens): string;
declare function tokenToObject(token: string): OAuth2Tokens;

declare function getYoutubeiInstance(): youtubei_js_agnostic.Innertube | undefined;

declare class LiveChatAuthor {
    username: string;
    url: string;
    thumbnail: string;
    verifiedChannel: boolean;
    verifiedArtist: boolean;
    isMod: boolean;
    id: string;
    raw: Author;
    constructor(author: Author);
}

declare enum ChatMessageType {
    Regular = 1,
    Premium = 2,
    PremiumSticker = 3
}
declare class LiveChatMessage {
    author: LiveChatAuthor;
    type: ChatMessageType;
    content?: string;
    timestamp: number;
    constructor(chatUpdate: YTNode, type: ChatMessageType);
}

declare enum LiveChatEvents {
    MessageCreate = "messageCreate"
}
interface LiveChatEventsData {
    [LiveChatEvents.MessageCreate]: (message: LiveChatMessage) => void;
}
declare class LiveChat extends TypedEmitter<LiveChatEventsData> {
    chat: ReturnType<typeof VideoInfo['prototype']['getLiveChat']>;
    chatUpdateHandler: (action: ChatAction) => void;
    constructor(chat: ReturnType<typeof VideoInfo['prototype']['getLiveChat']>);
    destroy(): void;
}

declare function getLiveChat(videoUrl: string, ext?: YoutubeiExtractor): Promise<LiveChat>;

declare function generateOauthTokens(): Promise<void>;

export { type AsyncTrackingContext, ChatMessageType, LiveChatEvents, type StreamOptions, YoutubeiExtractor, type YoutubeiOptions, generateOauthTokens, getLiveChat, getYoutubeiInstance, objectToToken, tokenToObject };
