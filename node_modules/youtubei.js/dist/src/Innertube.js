var _Innertube_session;
import { __awaiter, __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import Session from './core/Session.js';
import { Kids, Music, Studio } from './core/clients/index.js';
import { AccountManager, InteractionManager, PlaylistManager } from './core/managers/index.js';
import { Feed, TabbedFeed } from './core/mixins/index.js';
import { BrowseEndpoint, GetNotificationMenuEndpoint, GuideEndpoint, NextEndpoint, PlayerEndpoint, ResolveURLEndpoint, SearchEndpoint, Reel, Notification } from './core/endpoints/index.js';
import { Channel, Comments, Guide, HashtagFeed, History, HomeFeed, Library, NotificationsMenu, Playlist, Search, VideoInfo } from './parser/youtube/index.js';
import { ShortFormVideoInfo } from './parser/ytshorts/index.js';
import NavigationEndpoint from './parser/classes/NavigationEndpoint.js';
import * as Proto from './proto/index.js';
import * as Constants from './utils/Constants.js';
import { InnertubeError, generateRandomString, throwIfMissing } from './utils/Utils.js';
/**
 * Provides access to various services and modules in the YouTube API.
 */
class Innertube {
    constructor(session) {
        _Innertube_session.set(this, void 0);
        __classPrivateFieldSet(this, _Innertube_session, session, "f");
    }
    static create() {
        return __awaiter(this, arguments, void 0, function* (config = {}) {
            return new Innertube(yield Session.create(config));
        });
    }
    getInfo(target, client) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e;
            throwIfMissing({ target: target });
            let next_payload;
            if (target instanceof NavigationEndpoint) {
                next_payload = NextEndpoint.build({
                    video_id: (_a = target.payload) === null || _a === void 0 ? void 0 : _a.videoId,
                    playlist_id: (_b = target.payload) === null || _b === void 0 ? void 0 : _b.playlistId,
                    params: (_c = target.payload) === null || _c === void 0 ? void 0 : _c.params,
                    playlist_index: (_d = target.payload) === null || _d === void 0 ? void 0 : _d.index
                });
            }
            else if (typeof target === 'string') {
                next_payload = NextEndpoint.build({
                    video_id: target
                });
            }
            else {
                throw new InnertubeError('Invalid target. Expected a video id or NavigationEndpoint.', target);
            }
            if (!next_payload.videoId)
                throw new InnertubeError('Video id cannot be empty', next_payload);
            const player_payload = PlayerEndpoint.build({
                video_id: next_payload.videoId,
                playlist_id: next_payload === null || next_payload === void 0 ? void 0 : next_payload.playlistId,
                client: client,
                sts: (_e = __classPrivateFieldGet(this, _Innertube_session, "f").player) === null || _e === void 0 ? void 0 : _e.sts
            });
            const player_response = this.actions.execute(PlayerEndpoint.PATH, player_payload);
            const next_response = this.actions.execute(NextEndpoint.PATH, next_payload);
            const response = yield Promise.all([player_response, next_response]);
            const cpn = generateRandomString(16);
            return new VideoInfo(response, this.actions, cpn);
        });
    }
    getBasicInfo(video_id, client) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            throwIfMissing({ video_id });
            const response = yield this.actions.execute(PlayerEndpoint.PATH, PlayerEndpoint.build({
                video_id: video_id,
                client: client,
                sts: (_a = __classPrivateFieldGet(this, _Innertube_session, "f").player) === null || _a === void 0 ? void 0 : _a.sts
            }));
            const cpn = generateRandomString(16);
            return new VideoInfo([response], this.actions, cpn);
        });
    }
    getShortsVideoInfo(video_id, client) {
        return __awaiter(this, void 0, void 0, function* () {
            throwIfMissing({ video_id });
            const watch_response = this.actions.execute(Reel.ReelItemWatchEndpoint.PATH, Reel.ReelItemWatchEndpoint.build({ video_id, client }));
            const sequence_response = this.actions.execute(Reel.ReelWatchSequenceEndpoint.PATH, Reel.ReelWatchSequenceEndpoint.build({
                sequence_params: Proto.encodeReelSequence(video_id)
            }));
            const response = yield Promise.all([watch_response, sequence_response]);
            const cpn = generateRandomString(16);
            return new ShortFormVideoInfo([response[0]], this.actions, cpn, response[1]);
        });
    }
    search(query_1) {
        return __awaiter(this, arguments, void 0, function* (query, filters = {}) {
            throwIfMissing({ query });
            const response = yield this.actions.execute(SearchEndpoint.PATH, SearchEndpoint.build({
                query, params: filters ? Proto.encodeSearchFilters(filters) : undefined
            }));
            return new Search(this.actions, response);
        });
    }
    getSearchSuggestions(query) {
        return __awaiter(this, void 0, void 0, function* () {
            throwIfMissing({ query });
            const url = new URL(`${Constants.URLS.YT_SUGGESTIONS}search`);
            url.searchParams.set('q', query);
            url.searchParams.set('hl', __classPrivateFieldGet(this, _Innertube_session, "f").context.client.hl);
            url.searchParams.set('gl', __classPrivateFieldGet(this, _Innertube_session, "f").context.client.gl);
            url.searchParams.set('ds', 'yt');
            url.searchParams.set('client', 'youtube');
            url.searchParams.set('xssi', 't');
            url.searchParams.set('oe', 'UTF');
            const response = yield __classPrivateFieldGet(this, _Innertube_session, "f").http.fetch(url);
            const response_data = yield response.text();
            const data = JSON.parse(response_data.replace(')]}\'', ''));
            const suggestions = data[1].map((suggestion) => suggestion[0]);
            return suggestions;
        });
    }
    getComments(video_id, sort_by) {
        return __awaiter(this, void 0, void 0, function* () {
            throwIfMissing({ video_id });
            const response = yield this.actions.execute(NextEndpoint.PATH, NextEndpoint.build({
                continuation: Proto.encodeCommentsSectionParams(video_id, {
                    sort_by: sort_by || 'TOP_COMMENTS'
                })
            }));
            return new Comments(this.actions, response.data);
        });
    }
    getHomeFeed() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.actions.execute(BrowseEndpoint.PATH, BrowseEndpoint.build({ browse_id: 'FEwhat_to_watch' }));
            return new HomeFeed(this.actions, response);
        });
    }
    /**
     * Retrieves YouTube's content guide.
     */
    getGuide() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.actions.execute(GuideEndpoint.PATH);
            return new Guide(response.data);
        });
    }
    getLibrary() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.actions.execute(BrowseEndpoint.PATH, BrowseEndpoint.build({ browse_id: 'FElibrary' }));
            return new Library(this.actions, response);
        });
    }
    getHistory() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.actions.execute(BrowseEndpoint.PATH, BrowseEndpoint.build({ browse_id: 'FEhistory' }));
            return new History(this.actions, response);
        });
    }
    getTrending() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.actions.execute(BrowseEndpoint.PATH, Object.assign(Object.assign({}, BrowseEndpoint.build({ browse_id: 'FEtrending' })), { parse: true }));
            return new TabbedFeed(this.actions, response);
        });
    }
    getSubscriptionsFeed() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.actions.execute(BrowseEndpoint.PATH, Object.assign(Object.assign({}, BrowseEndpoint.build({ browse_id: 'FEsubscriptions' })), { parse: true }));
            return new Feed(this.actions, response);
        });
    }
    getChannelsFeed() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.actions.execute(BrowseEndpoint.PATH, Object.assign(Object.assign({}, BrowseEndpoint.build({ browse_id: 'FEchannels' })), { parse: true }));
            return new Feed(this.actions, response);
        });
    }
    getChannel(id) {
        return __awaiter(this, void 0, void 0, function* () {
            throwIfMissing({ id });
            const response = yield this.actions.execute(BrowseEndpoint.PATH, BrowseEndpoint.build({ browse_id: id }));
            return new Channel(this.actions, response);
        });
    }
    getNotifications() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.actions.execute(GetNotificationMenuEndpoint.PATH, GetNotificationMenuEndpoint.build({
                notifications_menu_request_type: 'NOTIFICATIONS_MENU_REQUEST_TYPE_INBOX'
            }));
            return new NotificationsMenu(this.actions, response);
        });
    }
    getUnseenNotificationsCount() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const response = yield this.actions.execute(Notification.GetUnseenCountEndpoint.PATH);
            // FIXME: properly parse this.
            return ((_a = response.data) === null || _a === void 0 ? void 0 : _a.unseenCount) || ((_d = (_c = (_b = response.data) === null || _b === void 0 ? void 0 : _b.actions) === null || _c === void 0 ? void 0 : _c[0].updateNotificationsUnseenCountAction) === null || _d === void 0 ? void 0 : _d.unseenCount) || 0;
        });
    }
    /**
     * Retrieves the user's playlists.
     */
    getPlaylists() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.actions.execute(BrowseEndpoint.PATH, Object.assign(Object.assign({}, BrowseEndpoint.build({ browse_id: 'FEplaylist_aggregation' })), { parse: true }));
            return new Feed(this.actions, response);
        });
    }
    getPlaylist(id) {
        return __awaiter(this, void 0, void 0, function* () {
            throwIfMissing({ id });
            if (!id.startsWith('VL')) {
                id = `VL${id}`;
            }
            const response = yield this.actions.execute(BrowseEndpoint.PATH, BrowseEndpoint.build({ browse_id: id }));
            return new Playlist(this.actions, response);
        });
    }
    getHashtag(hashtag) {
        return __awaiter(this, void 0, void 0, function* () {
            throwIfMissing({ hashtag });
            const response = yield this.actions.execute(BrowseEndpoint.PATH, BrowseEndpoint.build({
                browse_id: 'FEhashtag',
                params: Proto.encodeHashtag(hashtag)
            }));
            return new HashtagFeed(this.actions, response);
        });
    }
    /**
     * An alternative to {@link download}.
     * Returns deciphered streaming data.
     *
     * If you wish to retrieve the video info too, have a look at {@link getBasicInfo} or {@link getInfo}.
     * @param video_id - The video id.
     * @param options - Format options.
     */
    getStreamingData(video_id_1) {
        return __awaiter(this, arguments, void 0, function* (video_id, options = {}) {
            const info = yield this.getBasicInfo(video_id);
            const format = info.chooseFormat(options);
            format.url = format.decipher(__classPrivateFieldGet(this, _Innertube_session, "f").player);
            return format;
        });
    }
    /**
     * Downloads a given video. If all you need the direct download link, see {@link getStreamingData}.
     * If you wish to retrieve the video info too, have a look at {@link getBasicInfo} or {@link getInfo}.
     * @param video_id - The video id.
     * @param options - Download options.
     */
    download(video_id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield this.getBasicInfo(video_id, options === null || options === void 0 ? void 0 : options.client);
            return info.download(options);
        });
    }
    /**
     * Resolves the given URL.
     * @param url - The URL.
     */
    resolveURL(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.actions.execute(ResolveURLEndpoint.PATH, Object.assign(Object.assign({}, ResolveURLEndpoint.build({ url })), { parse: true }));
            if (!response.endpoint)
                throw new InnertubeError('Failed to resolve URL. Expected a NavigationEndpoint but got undefined', response);
            return response.endpoint;
        });
    }
    call(endpoint, args) {
        return endpoint.call(this.actions, args);
    }
    /**
     * An interface for interacting with YouTube Music.
     */
    get music() {
        return new Music(__classPrivateFieldGet(this, _Innertube_session, "f"));
    }
    /**
     * An interface for interacting with YouTube Studio.
     */
    get studio() {
        return new Studio(__classPrivateFieldGet(this, _Innertube_session, "f"));
    }
    /**
     * An interface for interacting with YouTube Kids.
     */
    get kids() {
        return new Kids(__classPrivateFieldGet(this, _Innertube_session, "f"));
    }
    /**
     * An interface for managing and retrieving account information.
     */
    get account() {
        return new AccountManager(__classPrivateFieldGet(this, _Innertube_session, "f").actions);
    }
    /**
     * An interface for managing playlists.
     */
    get playlist() {
        return new PlaylistManager(__classPrivateFieldGet(this, _Innertube_session, "f").actions);
    }
    /**
     * An interface for directly interacting with certain YouTube features.
     */
    get interact() {
        return new InteractionManager(__classPrivateFieldGet(this, _Innertube_session, "f").actions);
    }
    /**
     * An internal class used to dispatch requests.
     */
    get actions() {
        return __classPrivateFieldGet(this, _Innertube_session, "f").actions;
    }
    /**
     * The session used by this instance.
     */
    get session() {
        return __classPrivateFieldGet(this, _Innertube_session, "f");
    }
}
_Innertube_session = new WeakMap();
export default Innertube;
//# sourceMappingURL=Innertube.js.map